# Zerocut æ•°æ®åº“è®¾è®¡ä¼˜åŒ–æ–¹æ¡ˆ

## ğŸ“Š ç°æœ‰æ•°æ®åº“æ¶æ„åˆ†æ

### å½“å‰æ¶æ„ä¼˜åŠ¿

âœ… **é¢†åŸŸé©±åŠ¨è®¾è®¡(DDD)**: é‡‡ç”¨æ¸…æ™°çš„é¢†åŸŸåˆ’åˆ†ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•  
âœ… **PostgreSQL 17**: ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬ï¼Œæ”¯æŒå…ˆè¿›ç‰¹æ€§  
âœ… **å®Œæ•´çš„çº¦æŸ**: å¤–é”®ã€æ£€æŸ¥çº¦æŸã€å”¯ä¸€çº¦æŸè®¾è®¡åˆç†  
âœ… **ç´¢å¼•ä¼˜åŒ–**: é’ˆå¯¹æŸ¥è¯¢åœºæ™¯å»ºç«‹äº†åˆé€‚çš„ç´¢å¼•  
âœ… **è§¦å‘å™¨æœºåˆ¶**: è‡ªåŠ¨æ›´æ–°æ—¶é—´æˆ³ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§  
âœ… **åˆå§‹åŒ–æ•°æ®**: æä¾›äº†å®Œæ•´çš„ç¤ºä¾‹æ•°æ®

### æ¶æ„æ”¹è¿›å»ºè®®

#### 1. æ•°æ®åˆ†åŒºç­–ç•¥

```sql
-- æŒ‰æ—¶é—´åˆ†åŒºçš„ä½¿ç”¨ç»Ÿè®¡è¡¨
CREATE TABLE usage_stats_partitioned (
    id BIGSERIAL,
    workspace_id INTEGER NOT NULL,
    date DATE NOT NULL,
    api_calls INTEGER DEFAULT 0,
    tokens_used BIGINT DEFAULT 0,
    cost_amount DECIMAL(10,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (date);

-- åˆ›å»ºæœˆåº¦åˆ†åŒº
CREATE TABLE usage_stats_2024_01 PARTITION OF usage_stats_partitioned
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE usage_stats_2024_02 PARTITION OF usage_stats_partitioned
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- è‡ªåŠ¨åˆ†åŒºç®¡ç†å‡½æ•°
CREATE OR REPLACE FUNCTION create_monthly_partition(table_name TEXT, start_date DATE)
RETURNS VOID AS $$
DECLARE
    partition_name TEXT;
    end_date DATE;
BEGIN
    partition_name := table_name || '_' || to_char(start_date, 'YYYY_MM');
    end_date := start_date + INTERVAL '1 month';

    EXECUTE format('CREATE TABLE IF NOT EXISTS %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
                   partition_name, table_name, start_date, end_date);
END;
$$ LANGUAGE plpgsql;
```

#### 2. è¯»å†™åˆ†ç¦»æ¶æ„

```sql
-- åˆ›å»ºåªè¯»ç”¨æˆ·è§’è‰²
CREATE ROLE readonly_user;
GRANT CONNECT ON DATABASE zerocut TO readonly_user;
GRANT USAGE ON SCHEMA user_management, workspace_domain, financial_management TO readonly_user;
GRANT SELECT ON ALL TABLES IN SCHEMA user_management, workspace_domain, financial_management TO readonly_user;

-- åˆ›å»ºåˆ†æä¸“ç”¨è§†å›¾
CREATE MATERIALIZED VIEW mv_workspace_analytics AS
SELECT
    w.id as workspace_id,
    w.name as workspace_name,
    COUNT(DISTINCT uw.user_id) as member_count,
    COUNT(DISTINCT ak.id) as api_key_count,
    SUM(us.api_calls) as total_api_calls,
    SUM(us.tokens_used) as total_tokens_used,
    SUM(us.cost_amount) as total_cost,
    AVG(us.api_calls) as avg_daily_calls,
    MAX(us.date) as last_activity_date
FROM workspace_domain.WORKSPACE w
LEFT JOIN workspace_domain.USER_WORKSPACE uw ON w.id = uw.workspace_id AND uw.status = 'active'
LEFT JOIN api_management.API_KEY ak ON w.id = ak.workspace_id AND ak.status = 'active'
LEFT JOIN data_statistics.USAGE_STATS us ON w.id = us.workspace_id
WHERE w.status = 'active'
GROUP BY w.id, w.name;

-- åˆ›å»ºåˆ·æ–°ç‰©åŒ–è§†å›¾çš„å®šæ—¶ä»»åŠ¡
CREATE OR REPLACE FUNCTION refresh_analytics_views()
RETURNS VOID AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_workspace_analytics;
    -- å¯ä»¥æ·»åŠ æ›´å¤šç‰©åŒ–è§†å›¾çš„åˆ·æ–°
END;
$$ LANGUAGE plpgsql;

-- æ¯å°æ—¶åˆ·æ–°ä¸€æ¬¡ï¼ˆéœ€è¦é…åˆ pg_cron æ‰©å±•ï¼‰
-- SELECT cron.schedule('refresh-analytics', '0 * * * *', 'SELECT refresh_analytics_views();');
```

#### 3. æ•°æ®å½’æ¡£ç­–ç•¥

```sql
-- åˆ›å»ºå½’æ¡£è¡¨ç»“æ„
CREATE SCHEMA IF NOT EXISTS archive;

-- å½’æ¡£æ¶ˆè´¹è®°å½•ï¼ˆä¿ç•™æœ€è¿‘6ä¸ªæœˆçš„æ•°æ®ï¼‰
CREATE TABLE archive.consumption_record_archive (
    LIKE financial_management.CONSUMPTION_RECORD INCLUDING ALL
);

-- æ•°æ®å½’æ¡£å‡½æ•°
CREATE OR REPLACE FUNCTION archive_old_consumption_records()
RETURNS INTEGER AS $$
DECLARE
    archived_count INTEGER;
    cutoff_date DATE;
BEGIN
    cutoff_date := CURRENT_DATE - INTERVAL '6 months';

    -- ç§»åŠ¨æ—§æ•°æ®åˆ°å½’æ¡£è¡¨
    WITH moved_records AS (
        DELETE FROM financial_management.CONSUMPTION_RECORD
        WHERE created_at < cutoff_date
        RETURNING *
    )
    INSERT INTO archive.consumption_record_archive
    SELECT * FROM moved_records;

    GET DIAGNOSTICS archived_count = ROW_COUNT;

    -- è®°å½•å½’æ¡£æ“ä½œ
    INSERT INTO audit_log.SYSTEM_LOG (level, message, metadata)
    VALUES ('INFO', 'Archived consumption records',
            json_build_object('archived_count', archived_count, 'cutoff_date', cutoff_date));

    RETURN archived_count;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºå®šæ—¶å½’æ¡£ä»»åŠ¡
-- SELECT cron.schedule('archive-consumption', '0 2 1 * *', 'SELECT archive_old_consumption_records();');
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

### 1. ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

```sql
-- å¤åˆç´¢å¼•ä¼˜åŒ–
CREATE INDEX CONCURRENTLY idx_usage_stats_workspace_date_calls
    ON data_statistics.USAGE_STATS (workspace_id, date DESC, api_calls DESC);

CREATE INDEX CONCURRENTLY idx_consumption_record_workspace_created
    ON financial_management.CONSUMPTION_RECORD (workspace_id, created_at DESC)
    WHERE amount > 0;

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æ´»è·ƒæ•°æ®ï¼‰
CREATE INDEX CONCURRENTLY idx_user_active_email
    ON user_management."USER" (email)
    WHERE status = 'active';

CREATE INDEX CONCURRENTLY idx_workspace_active_code
    ON workspace_domain.WORKSPACE (code)
    WHERE status = 'active';

-- è¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_user_email_lower
    ON user_management."USER" (LOWER(email));

-- GINç´¢å¼•ç”¨äºJSONå­—æ®µæœç´¢
CREATE INDEX CONCURRENTLY idx_system_log_metadata_gin
    ON audit_log.SYSTEM_LOG USING GIN (metadata);
```

### 2. æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä¼˜åŒ–çš„ç”¨æˆ·å·¥ä½œç©ºé—´æŸ¥è¯¢
CREATE OR REPLACE VIEW v_user_workspace_optimized AS
SELECT
    u.id as user_id,
    u.email,
    u.username,
    w.id as workspace_id,
    w.name as workspace_name,
    w.code as workspace_code,
    uw.role,
    uw.is_owner,
    a.balance,
    COUNT(ak.id) as api_key_count,
    COALESCE(recent_stats.daily_calls, 0) as recent_daily_calls
FROM user_management."USER" u
JOIN workspace_domain.USER_WORKSPACE uw ON u.id = uw.user_id
JOIN workspace_domain.WORKSPACE w ON uw.workspace_id = w.id
LEFT JOIN financial_management.ACCOUNT a ON w.id = a.workspace_id
LEFT JOIN api_management.API_KEY ak ON w.id = ak.workspace_id AND ak.status = 'active'
LEFT JOIN LATERAL (
    SELECT AVG(api_calls) as daily_calls
    FROM data_statistics.USAGE_STATS us
    WHERE us.workspace_id = w.id
    AND us.date >= CURRENT_DATE - INTERVAL '7 days'
) recent_stats ON true
WHERE u.status = 'active'
  AND uw.status = 'active'
  AND w.status = 'active'
GROUP BY u.id, u.email, u.username, w.id, w.name, w.code,
         uw.role, uw.is_owner, a.balance, recent_stats.daily_calls;

-- é«˜æ•ˆçš„ç»Ÿè®¡æŸ¥è¯¢å‡½æ•°
CREATE OR REPLACE FUNCTION get_workspace_dashboard_stats(p_workspace_id INTEGER)
RETURNS JSON AS $$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'total_api_calls', COALESCE(SUM(us.api_calls), 0),
        'total_tokens_used', COALESCE(SUM(us.tokens_used), 0),
        'total_cost', COALESCE(SUM(us.cost_amount), 0),
        'avg_daily_calls', COALESCE(AVG(us.api_calls), 0),
        'member_count', (
            SELECT COUNT(*)
            FROM workspace_domain.USER_WORKSPACE uw
            WHERE uw.workspace_id = p_workspace_id AND uw.status = 'active'
        ),
        'api_key_count', (
            SELECT COUNT(*)
            FROM api_management.API_KEY ak
            WHERE ak.workspace_id = p_workspace_id AND ak.status = 'active'
        ),
        'current_balance', (
            SELECT balance
            FROM financial_management.ACCOUNT a
            WHERE a.workspace_id = p_workspace_id
        ),
        'last_30_days_trend', (
            SELECT json_agg(
                json_build_object(
                    'date', date,
                    'api_calls', api_calls,
                    'cost', cost_amount
                ) ORDER BY date
            )
            FROM data_statistics.USAGE_STATS us2
            WHERE us2.workspace_id = p_workspace_id
            AND us2.date >= CURRENT_DATE - INTERVAL '30 days'
        )
    ) INTO result
    FROM data_statistics.USAGE_STATS us
    WHERE us.workspace_id = p_workspace_id
    AND us.date >= CURRENT_DATE - INTERVAL '30 days';

    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

### 3. è¿æ¥æ± ä¼˜åŒ–

```sql
-- è¿æ¥æ± é…ç½®å»ºè®®
-- postgresql.conf ä¼˜åŒ–å‚æ•°
/*
max_connections = 200
shared_buffers = 256MB
effective_cache_size = 1GB
work_mem = 4MB
maintenance_work_mem = 64MB
checkpoint_completion_target = 0.9
wal_buffers = 16MB
default_statistics_target = 100
random_page_cost = 1.1
effective_io_concurrency = 200
*/

-- åˆ›å»ºè¿æ¥æ± ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_connection_stats AS
SELECT
    state,
    COUNT(*) as connection_count,
    AVG(EXTRACT(EPOCH FROM (now() - state_change))) as avg_duration_seconds
FROM pg_stat_activity
WHERE datname = current_database()
GROUP BY state;
```

## ğŸ”’ å®‰å…¨åŠ å›ºæ–¹æ¡ˆ

### 1. æ•°æ®åŠ å¯†

```sql
-- å¯ç”¨ pgcrypto æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
ALTER TABLE user_management."USER"
ADD COLUMN phone_encrypted BYTEA;

-- åŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_sensitive_data(data TEXT, key TEXT)
RETURNS BYTEA AS $$
BEGIN
    RETURN pgp_sym_encrypt(data, key);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- è§£å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION decrypt_sensitive_data(encrypted_data BYTEA, key TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN pgp_sym_decrypt(encrypted_data, key);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- æ•°æ®è¿ç§»ç¤ºä¾‹
-- UPDATE user_management."USER"
-- SET phone_encrypted = encrypt_sensitive_data(phone, 'your-encryption-key')
-- WHERE phone IS NOT NULL;
```

### 2. è¡Œçº§å®‰å…¨ç­–ç•¥

```sql
-- å¯ç”¨è¡Œçº§å®‰å…¨
ALTER TABLE workspace_domain.WORKSPACE ENABLE ROW LEVEL SECURITY;
ALTER TABLE financial_management.ACCOUNT ENABLE ROW LEVEL SECURITY;
ALTER TABLE data_statistics.USAGE_STATS ENABLE ROW LEVEL SECURITY;

-- å·¥ä½œç©ºé—´è®¿é—®ç­–ç•¥
CREATE POLICY workspace_access_policy ON workspace_domain.WORKSPACE
    FOR ALL TO application_user
    USING (
        id IN (
            SELECT workspace_id
            FROM workspace_domain.USER_WORKSPACE
            WHERE user_id = current_setting('app.current_user_id')::INTEGER
            AND status = 'active'
        )
    );

-- è´¦æˆ·è®¿é—®ç­–ç•¥
CREATE POLICY account_access_policy ON financial_management.ACCOUNT
    FOR ALL TO application_user
    USING (
        workspace_id IN (
            SELECT workspace_id
            FROM workspace_domain.USER_WORKSPACE
            WHERE user_id = current_setting('app.current_user_id')::INTEGER
            AND status = 'active'
        )
    );

-- ä½¿ç”¨ç»Ÿè®¡è®¿é—®ç­–ç•¥
CREATE POLICY usage_stats_access_policy ON data_statistics.USAGE_STATS
    FOR ALL TO application_user
    USING (
        workspace_id IN (
            SELECT workspace_id
            FROM workspace_domain.USER_WORKSPACE
            WHERE user_id = current_setting('app.current_user_id')::INTEGER
            AND status = 'active'
        )
    );
```

### 3. å®¡è®¡æ—¥å¿—å¢å¼º

```sql
-- åˆ›å»ºå®¡è®¡è§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
    old_data JSON;
    new_data JSON;
    user_id INTEGER;
BEGIN
    -- è·å–å½“å‰ç”¨æˆ·ID
    user_id := COALESCE(current_setting('app.current_user_id', true)::INTEGER, 0);

    IF TG_OP = 'DELETE' THEN
        old_data := row_to_json(OLD);
        INSERT INTO audit_log.SYSTEM_LOG (level, message, metadata, user_id)
        VALUES ('INFO', TG_TABLE_NAME || ' record deleted',
                json_build_object(
                    'operation', 'DELETE',
                    'table', TG_TABLE_NAME,
                    'old_data', old_data
                ), user_id);
        RETURN OLD;
    ELSIF TG_OP = 'UPDATE' THEN
        old_data := row_to_json(OLD);
        new_data := row_to_json(NEW);
        INSERT INTO audit_log.SYSTEM_LOG (level, message, metadata, user_id)
        VALUES ('INFO', TG_TABLE_NAME || ' record updated',
                json_build_object(
                    'operation', 'UPDATE',
                    'table', TG_TABLE_NAME,
                    'old_data', old_data,
                    'new_data', new_data
                ), user_id);
        RETURN NEW;
    ELSIF TG_OP = 'INSERT' THEN
        new_data := row_to_json(NEW);
        INSERT INTO audit_log.SYSTEM_LOG (level, message, metadata, user_id)
        VALUES ('INFO', TG_TABLE_NAME || ' record created',
                json_build_object(
                    'operation', 'INSERT',
                    'table', TG_TABLE_NAME,
                    'new_data', new_data
                ), user_id);
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- ä¸ºå…³é”®è¡¨æ·»åŠ å®¡è®¡è§¦å‘å™¨
CREATE TRIGGER audit_user_changes
    AFTER INSERT OR UPDATE OR DELETE ON user_management."USER"
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_workspace_changes
    AFTER INSERT OR UPDATE OR DELETE ON workspace_domain.WORKSPACE
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_account_changes
    AFTER INSERT OR UPDATE OR DELETE ON financial_management.ACCOUNT
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
```

## ğŸ“ˆ ç›‘æ§å’Œç»´æŠ¤

### 1. æ€§èƒ½ç›‘æ§è§†å›¾

```sql
-- æ…¢æŸ¥è¯¢ç›‘æ§
CREATE OR REPLACE VIEW v_slow_queries AS
SELECT
    query,
    calls,
    total_time,
    mean_time,
    rows,
    100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
FROM pg_stat_statements
WHERE mean_time > 100  -- è¶…è¿‡100msçš„æŸ¥è¯¢
ORDER BY mean_time DESC;

-- è¡¨å¤§å°ç›‘æ§
CREATE OR REPLACE VIEW v_table_sizes AS
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
    pg_total_relation_size(schemaname||'.'||tablename) as size_bytes
FROM pg_tables
WHERE schemaname NOT IN ('information_schema', 'pg_catalog')
ORDER BY size_bytes DESC;

-- ç´¢å¼•ä½¿ç”¨æƒ…å†µç›‘æ§
CREATE OR REPLACE VIEW v_index_usage AS
SELECT
    schemaname,
    tablename,
    indexname,
    idx_tup_read,
    idx_tup_fetch,
    idx_scan,
    CASE
        WHEN idx_scan = 0 THEN 'Unused'
        WHEN idx_scan < 100 THEN 'Low Usage'
        ELSE 'Active'
    END as usage_status
FROM pg_stat_user_indexes
ORDER BY idx_scan ASC;
```

### 2. è‡ªåŠ¨ç»´æŠ¤ä»»åŠ¡

```sql
-- è‡ªåŠ¨VACUUMå’ŒANALYZE
CREATE OR REPLACE FUNCTION auto_maintenance()
RETURNS VOID AS $$
DECLARE
    table_record RECORD;
BEGIN
    -- å¯¹å¤§è¡¨è¿›è¡Œç»´æŠ¤
    FOR table_record IN
        SELECT schemaname, tablename
        FROM pg_tables
        WHERE schemaname IN ('user_management', 'workspace_domain', 'financial_management', 'data_statistics')
    LOOP
        -- æ‰§è¡ŒANALYZEæ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        EXECUTE format('ANALYZE %I.%I', table_record.schemaname, table_record.tablename);

        -- è®°å½•ç»´æŠ¤æ“ä½œ
        INSERT INTO audit_log.SYSTEM_LOG (level, message, metadata)
        VALUES ('INFO', 'Auto maintenance completed',
                json_build_object('table', table_record.schemaname || '.' || table_record.tablename));
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- å®šæœŸæ‰§è¡Œç»´æŠ¤ä»»åŠ¡
-- SELECT cron.schedule('auto-maintenance', '0 3 * * 0', 'SELECT auto_maintenance();');
```

### 3. å¤‡ä»½ç­–ç•¥

```bash
#!/bin/bash
# backup_script.sh

# é…ç½®å˜é‡
DB_NAME="zerocut"
DB_USER="postgres"
BACKUP_DIR="/var/backups/postgresql"
DATE=$(date +"%Y%m%d_%H%M%S")
RETENTION_DAYS=30

# åˆ›å»ºå¤‡ä»½ç›®å½•
mkdir -p $BACKUP_DIR

# å…¨é‡å¤‡ä»½
pg_dump -U $DB_USER -h localhost -d $DB_NAME -F c -b -v -f "$BACKUP_DIR/zerocut_full_$DATE.backup"

# å‹ç¼©å¤‡ä»½æ–‡ä»¶
gzip "$BACKUP_DIR/zerocut_full_$DATE.backup"

# æ¸…ç†æ—§å¤‡ä»½
find $BACKUP_DIR -name "zerocut_full_*.backup.gz" -mtime +$RETENTION_DAYS -delete

# è®°å½•å¤‡ä»½çŠ¶æ€
if [ $? -eq 0 ]; then
    echo "$(date): Backup completed successfully" >> /var/log/postgresql_backup.log
else
    echo "$(date): Backup failed" >> /var/log/postgresql_backup.log
    exit 1
fi
```

## ğŸ”„ æ•°æ®è¿ç§»æ–¹æ¡ˆ

### 1. é›¶åœæœºè¿ç§»ç­–ç•¥

```sql
-- åˆ›å»ºæ–°è¡¨ç»“æ„ï¼ˆç¤ºä¾‹ï¼šä¼˜åŒ–ç”¨æˆ·è¡¨ï¼‰
CREATE TABLE user_management."USER_NEW" (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    username VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    phone_encrypted BYTEA,  -- æ–°å¢åŠ å¯†å­—æ®µ
    avatar_url TEXT,
    email_verified BOOLEAN DEFAULT FALSE,
    phone_verified BOOLEAN DEFAULT FALSE,
    status user_status DEFAULT 'active',
    last_login_at TIMESTAMP WITH TIME ZONE,
    login_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    -- æ–°å¢å­—æ®µ
    timezone VARCHAR(50) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'zh-CN',
    preferences JSONB DEFAULT '{}'
);

-- æ•°æ®è¿ç§»å‡½æ•°
CREATE OR REPLACE FUNCTION migrate_user_data()
RETURNS VOID AS $$
DECLARE
    batch_size INTEGER := 1000;
    offset_val INTEGER := 0;
    total_count INTEGER;
BEGIN
    -- è·å–æ€»è®°å½•æ•°
    SELECT COUNT(*) INTO total_count FROM user_management."USER";

    -- åˆ†æ‰¹è¿ç§»æ•°æ®
    WHILE offset_val < total_count LOOP
        INSERT INTO user_management."USER_NEW" (
            id, email, password_hash, username, phone, avatar_url,
            email_verified, phone_verified, status, last_login_at,
            login_attempts, locked_until, created_at, updated_at,
            phone_encrypted
        )
        SELECT
            id, email, password_hash, username, phone, avatar_url,
            email_verified, phone_verified, status, last_login_at,
            login_attempts, locked_until, created_at, updated_at,
            CASE
                WHEN phone IS NOT NULL THEN encrypt_sensitive_data(phone, 'migration-key')
                ELSE NULL
            END
        FROM user_management."USER"
        ORDER BY id
        LIMIT batch_size OFFSET offset_val;

        offset_val := offset_val + batch_size;

        -- è®°å½•è¿›åº¦
        RAISE NOTICE 'Migrated % of % records', offset_val, total_count;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### 2. ç‰ˆæœ¬æ§åˆ¶å’Œå›æ»š

```sql
-- åˆ›å»ºè¿ç§»ç‰ˆæœ¬è¡¨
CREATE TABLE IF NOT EXISTS migration_versions (
    version VARCHAR(50) PRIMARY KEY,
    description TEXT,
    applied_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    rollback_sql TEXT
);

-- è¿ç§»ç‰ˆæœ¬ç®¡ç†å‡½æ•°
CREATE OR REPLACE FUNCTION apply_migration(
    p_version VARCHAR(50),
    p_description TEXT,
    p_migration_sql TEXT,
    p_rollback_sql TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    migration_exists BOOLEAN;
BEGIN
    -- æ£€æŸ¥ç‰ˆæœ¬æ˜¯å¦å·²åº”ç”¨
    SELECT EXISTS(
        SELECT 1 FROM migration_versions WHERE version = p_version
    ) INTO migration_exists;

    IF migration_exists THEN
        RAISE NOTICE 'Migration % already applied', p_version;
        RETURN FALSE;
    END IF;

    -- æ‰§è¡Œè¿ç§»
    EXECUTE p_migration_sql;

    -- è®°å½•è¿ç§»ç‰ˆæœ¬
    INSERT INTO migration_versions (version, description, rollback_sql)
    VALUES (p_version, p_description, p_rollback_sql);

    RAISE NOTICE 'Migration % applied successfully', p_version;
    RETURN TRUE;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Migration % failed: %', p_version, SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- å›æ»šå‡½æ•°
CREATE OR REPLACE FUNCTION rollback_migration(p_version VARCHAR(50))
RETURNS BOOLEAN AS $$
DECLARE
    rollback_sql TEXT;
BEGIN
    -- è·å–å›æ»šSQL
    SELECT rollback_sql INTO rollback_sql
    FROM migration_versions
    WHERE version = p_version;

    IF rollback_sql IS NULL THEN
        RAISE EXCEPTION 'Migration % not found or no rollback available', p_version;
    END IF;

    -- æ‰§è¡Œå›æ»š
    EXECUTE rollback_sql;

    -- åˆ é™¤è¿ç§»è®°å½•
    DELETE FROM migration_versions WHERE version = p_version;

    RAISE NOTICE 'Migration % rolled back successfully', p_version;
    RETURN TRUE;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Rollback of migration % failed: %', p_version, SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

## ğŸ“‹ å®æ–½è®¡åˆ’

### é˜¶æ®µä¸€ï¼šåŸºç¡€ä¼˜åŒ– (1å‘¨)

- [x] ç´¢å¼•ä¼˜åŒ–å’ŒæŸ¥è¯¢æ€§èƒ½è°ƒä¼˜
- [x] è¿æ¥æ± é…ç½®ä¼˜åŒ–
- [x] ç›‘æ§è§†å›¾åˆ›å»º
- [ ] æ…¢æŸ¥è¯¢åˆ†æå’Œä¼˜åŒ–

### é˜¶æ®µäºŒï¼šå®‰å…¨åŠ å›º (1å‘¨)

- [ ] è¡Œçº§å®‰å…¨ç­–ç•¥å®æ–½
- [ ] æ•æ„Ÿæ•°æ®åŠ å¯†
- [ ] å®¡è®¡æ—¥å¿—å¢å¼º
- [ ] æƒé™ç»†åŒ–ç®¡ç†

### é˜¶æ®µä¸‰ï¼šé«˜å¯ç”¨æ¶æ„ (2å‘¨)

- [ ] è¯»å†™åˆ†ç¦»é…ç½®
- [ ] æ•°æ®åˆ†åŒºå®æ–½
- [ ] å¤‡ä»½æ¢å¤ç­–ç•¥
- [ ] æ•…éšœè½¬ç§»æœºåˆ¶

### é˜¶æ®µå››ï¼šæ€§èƒ½è°ƒä¼˜ (1å‘¨)

- [ ] ç‰©åŒ–è§†å›¾ä¼˜åŒ–
- [ ] ç¼“å­˜ç­–ç•¥å®æ–½
- [ ] æ•°æ®å½’æ¡£è‡ªåŠ¨åŒ–
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•

### é˜¶æ®µäº”ï¼šè¿ç»´è‡ªåŠ¨åŒ– (1å‘¨)

- [ ] è‡ªåŠ¨ç»´æŠ¤ä»»åŠ¡
- [ ] ç›‘æ§å‘Šè­¦é…ç½®
- [ ] å®¹é‡è§„åˆ’
- [ ] æ–‡æ¡£å®Œå–„

## ğŸ¯ é¢„æœŸæ•ˆæœ

### æ€§èƒ½æå‡

- æŸ¥è¯¢å“åº”æ—¶é—´å‡å°‘ 60%
- å¹¶å‘å¤„ç†èƒ½åŠ›æå‡ 3å€
- å­˜å‚¨ç©ºé—´ä¼˜åŒ– 40%
- ç¼“å­˜å‘½ä¸­ç‡è¾¾åˆ° 85%

### å¯ç”¨æ€§æ”¹è¿›

- ç³»ç»Ÿå¯ç”¨æ€§è¾¾åˆ° 99.9%
- æ•…éšœæ¢å¤æ—¶é—´ < 5åˆ†é’Ÿ
- æ•°æ®å¤‡ä»½æ¢å¤ < 30åˆ†é’Ÿ
- é›¶åœæœºç»´æŠ¤èƒ½åŠ›

### å®‰å…¨å¢å¼º

- æ•æ„Ÿæ•°æ®å…¨é¢åŠ å¯†
- ç»†ç²’åº¦æƒé™æ§åˆ¶
- å®Œæ•´å®¡è®¡è¿½è¸ª
- åˆè§„æ€§è¦æ±‚æ»¡è¶³

---

**æ³¨æ„äº‹é¡¹ï¼š**

1. æ‰€æœ‰ä¼˜åŒ–æ“ä½œéƒ½åº”åœ¨æµ‹è¯•ç¯å¢ƒå…ˆéªŒè¯
2. ç”Ÿäº§ç¯å¢ƒå˜æ›´éœ€è¦åˆ¶å®šè¯¦ç»†çš„å›æ»šè®¡åˆ’
3. å®šæœŸç›‘æ§æ€§èƒ½æŒ‡æ ‡å’Œç³»ç»Ÿå¥åº·çŠ¶å†µ
4. ä¿æŒæ•°æ®åº“ç‰ˆæœ¬æ›´æ–°å’Œå®‰å…¨è¡¥ä¸
5. å»ºç«‹å®Œå–„çš„å¤‡ä»½å’Œç¾éš¾æ¢å¤æœºåˆ¶
